// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: visualiser.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// velocity.report LiDAR Visualiser Protocol
// Version: v1
// Package: velocity.visualiser.v1
//
// This protobuf schema defines the API contract between the Go LiDAR pipeline
// and the macOS visualiser application. It supports:
// - Live streaming of point clouds, clusters, and tracks
// - Playback control for recorded logs
// - Debug overlays for algorithm tuning
// - Labelling workflow for classifier training

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Velocity_Visualiser_V1_DecimationMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case decimationNone // = 0
  case decimationUniform // = 1
  case decimationVoxel // = 2

  /// only foreground points, no background
  case decimationForegroundOnly // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .decimationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .decimationNone
    case 1: self = .decimationUniform
    case 2: self = .decimationVoxel
    case 3: self = .decimationForegroundOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .decimationNone: return 0
    case .decimationUniform: return 1
    case .decimationVoxel: return 2
    case .decimationForegroundOnly: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Velocity_Visualiser_V1_DecimationMode] = [
    .decimationNone,
    .decimationUniform,
    .decimationVoxel,
    .decimationForegroundOnly,
  ]

}

enum Velocity_Visualiser_V1_ClusteringMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case clusteringDbscan // = 0
  case clusteringConnectedComponents // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .clusteringDbscan
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .clusteringDbscan
    case 1: self = .clusteringConnectedComponents
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .clusteringDbscan: return 0
    case .clusteringConnectedComponents: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Velocity_Visualiser_V1_ClusteringMethod] = [
    .clusteringDbscan,
    .clusteringConnectedComponents,
  ]

}

enum Velocity_Visualiser_V1_TrackState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0

  /// new track, needs confirmation
  case tentative // = 1

  /// stable track
  case confirmed // = 2

  /// track marked for removal
  case deleted // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .tentative
    case 2: self = .confirmed
    case 3: self = .deleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .tentative: return 1
    case .confirmed: return 2
    case .deleted: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Velocity_Visualiser_V1_TrackState] = [
    .unknown,
    .tentative,
    .confirmed,
    .deleted,
  ]

}

enum Velocity_Visualiser_V1_OcclusionState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case occlusionNone // = 0
  case occlusionPartial // = 1
  case occlusionFull // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .occlusionNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .occlusionNone
    case 1: self = .occlusionPartial
    case 2: self = .occlusionFull
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .occlusionNone: return 0
    case .occlusionPartial: return 1
    case .occlusionFull: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Velocity_Visualiser_V1_OcclusionState] = [
    .occlusionNone,
    .occlusionPartial,
    .occlusionFull,
  ]

}

enum Velocity_Visualiser_V1_MotionModel: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// constant velocity
  case cv // = 0

  /// constant acceleration
  case ca // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .cv
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cv
    case 1: self = .ca
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cv: return 0
    case .ca: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Velocity_Visualiser_V1_MotionModel] = [
    .cv,
    .ca,
  ]

}

struct Velocity_Visualiser_V1_CoordinateFrameInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g., "site/hesai-01"
  var frameID: String = String()

  /// e.g., "ENU" or "sensor"
  var referenceFrame: String = String()

  /// optional, for georeferencing
  var originLat: Double = 0

  var originLon: Double = 0

  var originAlt: Double = 0

  /// rotation of X-axis from East (ENU)
  var rotationDeg: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_PointCloudFrame: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frameID: UInt64 = 0

  var timestampNs: Int64 = 0

  var sensorID: String = String()

  /// Compact encoding: arrays of equal length
  var x: [Float] = []

  /// world frame Y (metres)
  var y: [Float] = []

  /// world frame Z (metres)
  var z: [Float] = []

  /// 0-255
  var intensity: [UInt32] = []

  /// Optional: per-point classification (background=0, foreground=1, ground=2)
  var classification: [UInt32] = []

  /// Decimation info
  var decimationMode: Velocity_Visualiser_V1_DecimationMode = .decimationNone

  /// e.g., 0.5 = half the points
  var decimationRatio: Float = 0

  /// Point count (convenience field)
  var pointCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OrientedBoundingBox represents a 7-DOF (7 Degrees of Freedom) 3D bounding box.
/// This format conforms to the AV industry standard specification.
/// See: docs/lidar/future/av-lidar-integration-plan.md for BoundingBox7DOF spec.
///
/// 7-DOF parameters:
///   1. center_x: Centre X position (metres, world frame)
///   2. center_y: Centre Y position (metres, world frame)
///   3. center_z: Centre Z position (metres, world frame)
///   4. length:   Box extent along heading direction (metres)
///   5. width:    Box extent perpendicular to heading (metres)
///   6. height:   Box extent along Z-axis (metres)
///   7. heading:  Yaw angle around Z-axis (radians, [-π, π])
struct Velocity_Visualiser_V1_OrientedBoundingBox: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// metres, world frame
  var centerX: Float = 0

  /// metres, world frame
  var centerY: Float = 0

  /// metres, world frame
  var centerZ: Float = 0

  /// metres, along heading direction
  var length: Float = 0

  /// metres, perpendicular to heading
  var width: Float = 0

  /// metres, Z extent
  var height: Float = 0

  /// radians, rotation around Z-axis, [-π, π]
  var headingRad: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_Cluster: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique within frame
  var clusterID: Int64 {
    get {return _storage._clusterID}
    set {_uniqueStorage()._clusterID = newValue}
  }

  var sensorID: String {
    get {return _storage._sensorID}
    set {_uniqueStorage()._sensorID = newValue}
  }

  var timestampNs: Int64 {
    get {return _storage._timestampNs}
    set {_uniqueStorage()._timestampNs = newValue}
  }

  /// Centroid in world frame
  var centroidX: Float {
    get {return _storage._centroidX}
    set {_uniqueStorage()._centroidX = newValue}
  }

  var centroidY: Float {
    get {return _storage._centroidY}
    set {_uniqueStorage()._centroidY = newValue}
  }

  var centroidZ: Float {
    get {return _storage._centroidZ}
    set {_uniqueStorage()._centroidZ = newValue}
  }

  /// Axis-aligned bounding box
  var aabbLength: Float {
    get {return _storage._aabbLength}
    set {_uniqueStorage()._aabbLength = newValue}
  }

  /// Y extent (metres)
  var aabbWidth: Float {
    get {return _storage._aabbWidth}
    set {_uniqueStorage()._aabbWidth = newValue}
  }

  /// Z extent (metres)
  var aabbHeight: Float {
    get {return _storage._aabbHeight}
    set {_uniqueStorage()._aabbHeight = newValue}
  }

  /// Oriented bounding box (if computed)
  var obb: Velocity_Visualiser_V1_OrientedBoundingBox {
    get {return _storage._obb ?? Velocity_Visualiser_V1_OrientedBoundingBox()}
    set {_uniqueStorage()._obb = newValue}
  }
  /// Returns true if `obb` has been explicitly set.
  var hasObb: Bool {return _storage._obb != nil}
  /// Clears the value of `obb`. Subsequent reads from it will return its default value.
  mutating func clearObb() {_uniqueStorage()._obb = nil}

  /// Features
  var pointsCount: Int32 {
    get {return _storage._pointsCount}
    set {_uniqueStorage()._pointsCount = newValue}
  }

  var heightP95: Float {
    get {return _storage._heightP95}
    set {_uniqueStorage()._heightP95 = newValue}
  }

  var intensityMean: Float {
    get {return _storage._intensityMean}
    set {_uniqueStorage()._intensityMean = newValue}
  }

  /// Optional: sample points for debug rendering (xyz interleaved)
  var samplePoints: [Float] {
    get {return _storage._samplePoints}
    set {_uniqueStorage()._samplePoints = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Velocity_Visualiser_V1_ClusterSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frameID: UInt64 = 0

  var timestampNs: Int64 = 0

  var clusters: [Velocity_Visualiser_V1_Cluster] = []

  var method: Velocity_Visualiser_V1_ClusteringMethod = .clusteringDbscan

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_Track: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g., "track_42"
  var trackID: String {
    get {return _storage._trackID}
    set {_uniqueStorage()._trackID = newValue}
  }

  var sensorID: String {
    get {return _storage._sensorID}
    set {_uniqueStorage()._sensorID = newValue}
  }

  /// Lifecycle
  var state: Velocity_Visualiser_V1_TrackState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// consecutive successful associations
  var hits: Int32 {
    get {return _storage._hits}
    set {_uniqueStorage()._hits = newValue}
  }

  /// consecutive missed associations
  var misses: Int32 {
    get {return _storage._misses}
    set {_uniqueStorage()._misses = newValue}
  }

  /// total observations
  var observationCount: Int32 {
    get {return _storage._observationCount}
    set {_uniqueStorage()._observationCount = newValue}
  }

  /// Timestamps
  var firstSeenNs: Int64 {
    get {return _storage._firstSeenNs}
    set {_uniqueStorage()._firstSeenNs = newValue}
  }

  var lastSeenNs: Int64 {
    get {return _storage._lastSeenNs}
    set {_uniqueStorage()._lastSeenNs = newValue}
  }

  /// Current position (world frame)
  var x: Float {
    get {return _storage._x}
    set {_uniqueStorage()._x = newValue}
  }

  var y: Float {
    get {return _storage._y}
    set {_uniqueStorage()._y = newValue}
  }

  var z: Float {
    get {return _storage._z}
    set {_uniqueStorage()._z = newValue}
  }

  /// Current velocity (world frame)
  var vx: Float {
    get {return _storage._vx}
    set {_uniqueStorage()._vx = newValue}
  }

  var vy: Float {
    get {return _storage._vy}
    set {_uniqueStorage()._vy = newValue}
  }

  /// typically 0 for ground-plane tracking
  var vz: Float {
    get {return _storage._vz}
    set {_uniqueStorage()._vz = newValue}
  }

  /// Derived kinematics
  var speedMps: Float {
    get {return _storage._speedMps}
    set {_uniqueStorage()._speedMps = newValue}
  }

  var headingRad: Float {
    get {return _storage._headingRad}
    set {_uniqueStorage()._headingRad = newValue}
  }

  /// Uncertainty (optional, row-major 4x4)
  var covariance4X4: [Float] {
    get {return _storage._covariance4X4}
    set {_uniqueStorage()._covariance4X4 = newValue}
  }

  /// Bounding box (running average)
  var bboxLengthAvg: Float {
    get {return _storage._bboxLengthAvg}
    set {_uniqueStorage()._bboxLengthAvg = newValue}
  }

  var bboxWidthAvg: Float {
    get {return _storage._bboxWidthAvg}
    set {_uniqueStorage()._bboxWidthAvg = newValue}
  }

  var bboxHeightAvg: Float {
    get {return _storage._bboxHeightAvg}
    set {_uniqueStorage()._bboxHeightAvg = newValue}
  }

  /// OBB heading (smoothed)
  var bboxHeadingRad: Float {
    get {return _storage._bboxHeadingRad}
    set {_uniqueStorage()._bboxHeadingRad = newValue}
  }

  /// Features
  var heightP95Max: Float {
    get {return _storage._heightP95Max}
    set {_uniqueStorage()._heightP95Max = newValue}
  }

  var intensityMeanAvg: Float {
    get {return _storage._intensityMeanAvg}
    set {_uniqueStorage()._intensityMeanAvg = newValue}
  }

  var avgSpeedMps: Float {
    get {return _storage._avgSpeedMps}
    set {_uniqueStorage()._avgSpeedMps = newValue}
  }

  var peakSpeedMps: Float {
    get {return _storage._peakSpeedMps}
    set {_uniqueStorage()._peakSpeedMps = newValue}
  }

  /// Classification
  var classLabel: String {
    get {return _storage._classLabel}
    set {_uniqueStorage()._classLabel = newValue}
  }

  /// 0.0 - 1.0
  var classConfidence: Float {
    get {return _storage._classConfidence}
    set {_uniqueStorage()._classConfidence = newValue}
  }

  /// Quality metrics
  var trackLengthMetres: Float {
    get {return _storage._trackLengthMetres}
    set {_uniqueStorage()._trackLengthMetres = newValue}
  }

  var trackDurationSecs: Float {
    get {return _storage._trackDurationSecs}
    set {_uniqueStorage()._trackDurationSecs = newValue}
  }

  var occlusionCount: Int32 {
    get {return _storage._occlusionCount}
    set {_uniqueStorage()._occlusionCount = newValue}
  }

  var confidence: Float {
    get {return _storage._confidence}
    set {_uniqueStorage()._confidence = newValue}
  }

  var occlusionState: Velocity_Visualiser_V1_OcclusionState {
    get {return _storage._occlusionState}
    set {_uniqueStorage()._occlusionState = newValue}
  }

  var motionModel: Velocity_Visualiser_V1_MotionModel {
    get {return _storage._motionModel}
    set {_uniqueStorage()._motionModel = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Velocity_Visualiser_V1_TrackPoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var timestampNs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_TrackTrail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackID: String = String()

  var points: [Velocity_Visualiser_V1_TrackPoint] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_TrackSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frameID: UInt64 = 0

  var timestampNs: Int64 = 0

  var tracks: [Velocity_Visualiser_V1_Track] = []

  /// historical positions for rendering
  var trails: [Velocity_Visualiser_V1_TrackTrail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_AssociationCandidate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var clusterID: Int64 = 0

  var trackID: String = String()

  /// Mahalanobis distance
  var distance: Float = 0

  /// whether association was accepted
  var accepted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_GatingEllipse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackID: String = String()

  var centerX: Float = 0

  var centerY: Float = 0

  /// metres
  var semiMajor: Float = 0

  /// metres
  var semiMinor: Float = 0

  /// ellipse rotation
  var rotationRad: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_InnovationResidual: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackID: String = String()

  var predictedX: Float = 0

  var predictedY: Float = 0

  var measuredX: Float = 0

  var measuredY: Float = 0

  var residualMagnitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_StatePrediction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trackID: String = String()

  var x: Float = 0

  var y: Float = 0

  var vx: Float = 0

  var vy: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_DebugOverlaySet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frameID: UInt64 = 0

  var timestampNs: Int64 = 0

  var associationCandidates: [Velocity_Visualiser_V1_AssociationCandidate] = []

  var gatingEllipses: [Velocity_Visualiser_V1_GatingEllipse] = []

  var residuals: [Velocity_Visualiser_V1_InnovationResidual] = []

  var predictions: [Velocity_Visualiser_V1_StatePrediction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_LabelEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  var labelID: String = String()

  /// associated track
  var trackID: String = String()

  /// assigned class
  var classLabel: String = String()

  /// segment start (optional)
  var startFrameID: UInt64 = 0

  /// segment end (optional)
  var endFrameID: UInt64 = 0

  /// when label was created
  var createdNs: Int64 = 0

  /// optional: who created the label
  var annotator: String = String()

  /// optional: free-form notes
  var notes: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_LabelSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// replay session identifier
  var sessionID: String = String()

  /// log file being annotated
  var sourceFile: String = String()

  var labels: [Velocity_Visualiser_V1_LabelEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_PlaybackInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true if live, false if replay
  var isLive: Bool = false

  /// first frame timestamp in log
  var logStartNs: Int64 = 0

  /// last frame timestamp in log
  var logEndNs: Int64 = 0

  /// 1.0 = real-time
  var playbackRate: Float = 0

  var paused: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_FrameBundle: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frameID: UInt64 {
    get {return _storage._frameID}
    set {_uniqueStorage()._frameID = newValue}
  }

  var timestampNs: Int64 {
    get {return _storage._timestampNs}
    set {_uniqueStorage()._timestampNs = newValue}
  }

  var sensorID: String {
    get {return _storage._sensorID}
    set {_uniqueStorage()._sensorID = newValue}
  }

  var coordinateFrame: Velocity_Visualiser_V1_CoordinateFrameInfo {
    get {return _storage._coordinateFrame ?? Velocity_Visualiser_V1_CoordinateFrameInfo()}
    set {_uniqueStorage()._coordinateFrame = newValue}
  }
  /// Returns true if `coordinateFrame` has been explicitly set.
  var hasCoordinateFrame: Bool {return _storage._coordinateFrame != nil}
  /// Clears the value of `coordinateFrame`. Subsequent reads from it will return its default value.
  mutating func clearCoordinateFrame() {_uniqueStorage()._coordinateFrame = nil}

  var pointCloud: Velocity_Visualiser_V1_PointCloudFrame {
    get {return _storage._pointCloud ?? Velocity_Visualiser_V1_PointCloudFrame()}
    set {_uniqueStorage()._pointCloud = newValue}
  }
  /// Returns true if `pointCloud` has been explicitly set.
  var hasPointCloud: Bool {return _storage._pointCloud != nil}
  /// Clears the value of `pointCloud`. Subsequent reads from it will return its default value.
  mutating func clearPointCloud() {_uniqueStorage()._pointCloud = nil}

  var clusters: Velocity_Visualiser_V1_ClusterSet {
    get {return _storage._clusters ?? Velocity_Visualiser_V1_ClusterSet()}
    set {_uniqueStorage()._clusters = newValue}
  }
  /// Returns true if `clusters` has been explicitly set.
  var hasClusters: Bool {return _storage._clusters != nil}
  /// Clears the value of `clusters`. Subsequent reads from it will return its default value.
  mutating func clearClusters() {_uniqueStorage()._clusters = nil}

  var tracks: Velocity_Visualiser_V1_TrackSet {
    get {return _storage._tracks ?? Velocity_Visualiser_V1_TrackSet()}
    set {_uniqueStorage()._tracks = newValue}
  }
  /// Returns true if `tracks` has been explicitly set.
  var hasTracks: Bool {return _storage._tracks != nil}
  /// Clears the value of `tracks`. Subsequent reads from it will return its default value.
  mutating func clearTracks() {_uniqueStorage()._tracks = nil}

  var debug: Velocity_Visualiser_V1_DebugOverlaySet {
    get {return _storage._debug ?? Velocity_Visualiser_V1_DebugOverlaySet()}
    set {_uniqueStorage()._debug = newValue}
  }
  /// Returns true if `debug` has been explicitly set.
  var hasDebug: Bool {return _storage._debug != nil}
  /// Clears the value of `debug`. Subsequent reads from it will return its default value.
  mutating func clearDebug() {_uniqueStorage()._debug = nil}

  /// Playback metadata (replay mode only)
  var playbackInfo: Velocity_Visualiser_V1_PlaybackInfo {
    get {return _storage._playbackInfo ?? Velocity_Visualiser_V1_PlaybackInfo()}
    set {_uniqueStorage()._playbackInfo = newValue}
  }
  /// Returns true if `playbackInfo` has been explicitly set.
  var hasPlaybackInfo: Bool {return _storage._playbackInfo != nil}
  /// Clears the value of `playbackInfo`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackInfo() {_uniqueStorage()._playbackInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Velocity_Visualiser_V1_StreamRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// which sensor to stream (or "all")
  var sensorID: String = String()

  /// include full point cloud
  var includePoints: Bool = false

  /// include cluster set
  var includeClusters: Bool = false

  /// include track set
  var includeTracks: Bool = false

  /// include debug overlays
  var includeDebug: Bool = false

  var pointDecimation: Velocity_Visualiser_V1_DecimationMode = .decimationNone

  /// 0.0-1.0
  var decimationRatio: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_PlaybackStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paused: Bool = false

  var rate: Float = 0

  var currentTimestampNs: Int64 = 0

  var currentFrameID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_PauseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_PlayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_SeekRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Velocity_Visualiser_V1_SeekRequest.OneOf_Target? = nil

  /// seek to timestamp
  var timestampNs: Int64 {
    get {
      if case .timestampNs(let v)? = target {return v}
      return 0
    }
    set {target = .timestampNs(newValue)}
  }

  /// seek to frame
  var frameID: UInt64 {
    get {
      if case .frameID(let v)? = target {return v}
      return 0
    }
    set {target = .frameID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable, Sendable {
    /// seek to timestamp
    case timestampNs(Int64)
    /// seek to frame
    case frameID(UInt64)

  }

  init() {}
}

struct Velocity_Visualiser_V1_SetRateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g., 0.5, 1.0, 2.0
  var rate: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_OverlayModeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var showPoints: Bool = false

  var showClusters: Bool = false

  var showTracks: Bool = false

  var showTrails: Bool = false

  var showVelocity: Bool = false

  var showGating: Bool = false

  var showAssociation: Bool = false

  var showResiduals: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_OverlayModeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_CapabilitiesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_CapabilitiesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var supportsPoints: Bool = false

  var supportsClusters: Bool = false

  var supportsTracks: Bool = false

  var supportsDebug: Bool = false

  var supportsReplay: Bool = false

  var supportsRecording: Bool = false

  var availableSensors: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_RecordingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// optional, server may generate
  var outputPath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Velocity_Visualiser_V1_RecordingStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recording: Bool = false

  var outputPath: String = String()

  var framesRecorded: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "velocity.visualiser.v1"

extension Velocity_Visualiser_V1_DecimationMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DECIMATION_NONE\0\u{1}DECIMATION_UNIFORM\0\u{1}DECIMATION_VOXEL\0\u{1}DECIMATION_FOREGROUND_ONLY\0")
}

extension Velocity_Visualiser_V1_ClusteringMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CLUSTERING_DBSCAN\0\u{1}CLUSTERING_CONNECTED_COMPONENTS\0")
}

extension Velocity_Visualiser_V1_TrackState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TRACK_STATE_UNKNOWN\0\u{1}TRACK_STATE_TENTATIVE\0\u{1}TRACK_STATE_CONFIRMED\0\u{1}TRACK_STATE_DELETED\0")
}

extension Velocity_Visualiser_V1_OcclusionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OCCLUSION_NONE\0\u{1}OCCLUSION_PARTIAL\0\u{1}OCCLUSION_FULL\0")
}

extension Velocity_Visualiser_V1_MotionModel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MOTION_MODEL_CV\0\u{1}MOTION_MODEL_CA\0")
}

extension Velocity_Visualiser_V1_CoordinateFrameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoordinateFrameInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frame_id\0\u{3}reference_frame\0\u{3}origin_lat\0\u{3}origin_lon\0\u{3}origin_alt\0\u{3}rotation_deg\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.frameID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.referenceFrame) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.originLat) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.originLon) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.originAlt) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.rotationDeg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frameID.isEmpty {
      try visitor.visitSingularStringField(value: self.frameID, fieldNumber: 1)
    }
    if !self.referenceFrame.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceFrame, fieldNumber: 2)
    }
    if self.originLat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.originLat, fieldNumber: 3)
    }
    if self.originLon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.originLon, fieldNumber: 4)
    }
    if self.originAlt.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.originAlt, fieldNumber: 5)
    }
    if self.rotationDeg.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rotationDeg, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_CoordinateFrameInfo, rhs: Velocity_Visualiser_V1_CoordinateFrameInfo) -> Bool {
    if lhs.frameID != rhs.frameID {return false}
    if lhs.referenceFrame != rhs.referenceFrame {return false}
    if lhs.originLat != rhs.originLat {return false}
    if lhs.originLon != rhs.originLon {return false}
    if lhs.originAlt != rhs.originAlt {return false}
    if lhs.rotationDeg != rhs.rotationDeg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_PointCloudFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PointCloudFrame"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frame_id\0\u{3}timestamp_ns\0\u{3}sensor_id\0\u{1}x\0\u{1}y\0\u{1}z\0\u{1}intensity\0\u{1}classification\0\u{3}decimation_mode\0\u{3}decimation_ratio\0\u{3}point_count\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.frameID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampNs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sensorID) }()
      case 4: try { try decoder.decodeRepeatedFloatField(value: &self.x) }()
      case 5: try { try decoder.decodeRepeatedFloatField(value: &self.y) }()
      case 6: try { try decoder.decodeRepeatedFloatField(value: &self.z) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.intensity) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.classification) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.decimationMode) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.decimationRatio) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.pointCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.frameID, fieldNumber: 1)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampNs, fieldNumber: 2)
    }
    if !self.sensorID.isEmpty {
      try visitor.visitSingularStringField(value: self.sensorID, fieldNumber: 3)
    }
    if !self.x.isEmpty {
      try visitor.visitPackedFloatField(value: self.x, fieldNumber: 4)
    }
    if !self.y.isEmpty {
      try visitor.visitPackedFloatField(value: self.y, fieldNumber: 5)
    }
    if !self.z.isEmpty {
      try visitor.visitPackedFloatField(value: self.z, fieldNumber: 6)
    }
    if !self.intensity.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.intensity, fieldNumber: 7)
    }
    if !self.classification.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.classification, fieldNumber: 8)
    }
    if self.decimationMode != .decimationNone {
      try visitor.visitSingularEnumField(value: self.decimationMode, fieldNumber: 9)
    }
    if self.decimationRatio.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.decimationRatio, fieldNumber: 10)
    }
    if self.pointCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pointCount, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_PointCloudFrame, rhs: Velocity_Visualiser_V1_PointCloudFrame) -> Bool {
    if lhs.frameID != rhs.frameID {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.sensorID != rhs.sensorID {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.intensity != rhs.intensity {return false}
    if lhs.classification != rhs.classification {return false}
    if lhs.decimationMode != rhs.decimationMode {return false}
    if lhs.decimationRatio != rhs.decimationRatio {return false}
    if lhs.pointCount != rhs.pointCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_OrientedBoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OrientedBoundingBox"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}center_x\0\u{3}center_y\0\u{3}center_z\0\u{1}length\0\u{1}width\0\u{1}height\0\u{3}heading_rad\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.centerX) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.centerY) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.centerZ) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.length) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.headingRad) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.centerX.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.centerX, fieldNumber: 1)
    }
    if self.centerY.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.centerY, fieldNumber: 2)
    }
    if self.centerZ.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.centerZ, fieldNumber: 3)
    }
    if self.length.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.length, fieldNumber: 4)
    }
    if self.width.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 5)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 6)
    }
    if self.headingRad.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.headingRad, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_OrientedBoundingBox, rhs: Velocity_Visualiser_V1_OrientedBoundingBox) -> Bool {
    if lhs.centerX != rhs.centerX {return false}
    if lhs.centerY != rhs.centerY {return false}
    if lhs.centerZ != rhs.centerZ {return false}
    if lhs.length != rhs.length {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.headingRad != rhs.headingRad {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Cluster"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cluster_id\0\u{3}sensor_id\0\u{3}timestamp_ns\0\u{3}centroid_x\0\u{3}centroid_y\0\u{3}centroid_z\0\u{3}aabb_length\0\u{3}aabb_width\0\u{3}aabb_height\0\u{1}obb\0\u{3}points_count\0\u{3}height_p95\0\u{3}intensity_mean\0\u{3}sample_points\0")

  fileprivate class _StorageClass {
    var _clusterID: Int64 = 0
    var _sensorID: String = String()
    var _timestampNs: Int64 = 0
    var _centroidX: Float = 0
    var _centroidY: Float = 0
    var _centroidZ: Float = 0
    var _aabbLength: Float = 0
    var _aabbWidth: Float = 0
    var _aabbHeight: Float = 0
    var _obb: Velocity_Visualiser_V1_OrientedBoundingBox? = nil
    var _pointsCount: Int32 = 0
    var _heightP95: Float = 0
    var _intensityMean: Float = 0
    var _samplePoints: [Float] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clusterID = source._clusterID
      _sensorID = source._sensorID
      _timestampNs = source._timestampNs
      _centroidX = source._centroidX
      _centroidY = source._centroidY
      _centroidZ = source._centroidZ
      _aabbLength = source._aabbLength
      _aabbWidth = source._aabbWidth
      _aabbHeight = source._aabbHeight
      _obb = source._obb
      _pointsCount = source._pointsCount
      _heightP95 = source._heightP95
      _intensityMean = source._intensityMean
      _samplePoints = source._samplePoints
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._clusterID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sensorID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._timestampNs) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._centroidX) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._centroidY) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._centroidZ) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._aabbLength) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._aabbWidth) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._aabbHeight) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._obb) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._pointsCount) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._heightP95) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._intensityMean) }()
        case 14: try { try decoder.decodeRepeatedFloatField(value: &_storage._samplePoints) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._clusterID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._clusterID, fieldNumber: 1)
      }
      if !_storage._sensorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorID, fieldNumber: 2)
      }
      if _storage._timestampNs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampNs, fieldNumber: 3)
      }
      if _storage._centroidX.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._centroidX, fieldNumber: 4)
      }
      if _storage._centroidY.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._centroidY, fieldNumber: 5)
      }
      if _storage._centroidZ.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._centroidZ, fieldNumber: 6)
      }
      if _storage._aabbLength.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._aabbLength, fieldNumber: 7)
      }
      if _storage._aabbWidth.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._aabbWidth, fieldNumber: 8)
      }
      if _storage._aabbHeight.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._aabbHeight, fieldNumber: 9)
      }
      try { if let v = _storage._obb {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._pointsCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pointsCount, fieldNumber: 11)
      }
      if _storage._heightP95.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._heightP95, fieldNumber: 12)
      }
      if _storage._intensityMean.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._intensityMean, fieldNumber: 13)
      }
      if !_storage._samplePoints.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._samplePoints, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_Cluster, rhs: Velocity_Visualiser_V1_Cluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clusterID != rhs_storage._clusterID {return false}
        if _storage._sensorID != rhs_storage._sensorID {return false}
        if _storage._timestampNs != rhs_storage._timestampNs {return false}
        if _storage._centroidX != rhs_storage._centroidX {return false}
        if _storage._centroidY != rhs_storage._centroidY {return false}
        if _storage._centroidZ != rhs_storage._centroidZ {return false}
        if _storage._aabbLength != rhs_storage._aabbLength {return false}
        if _storage._aabbWidth != rhs_storage._aabbWidth {return false}
        if _storage._aabbHeight != rhs_storage._aabbHeight {return false}
        if _storage._obb != rhs_storage._obb {return false}
        if _storage._pointsCount != rhs_storage._pointsCount {return false}
        if _storage._heightP95 != rhs_storage._heightP95 {return false}
        if _storage._intensityMean != rhs_storage._intensityMean {return false}
        if _storage._samplePoints != rhs_storage._samplePoints {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_ClusterSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterSet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frame_id\0\u{3}timestamp_ns\0\u{1}clusters\0\u{1}method\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.frameID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampNs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.frameID, fieldNumber: 1)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampNs, fieldNumber: 2)
    }
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 3)
    }
    if self.method != .clusteringDbscan {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_ClusterSet, rhs: Velocity_Visualiser_V1_ClusterSet) -> Bool {
    if lhs.frameID != rhs.frameID {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.clusters != rhs.clusters {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Track"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}track_id\0\u{3}sensor_id\0\u{1}state\0\u{1}hits\0\u{1}misses\0\u{3}observation_count\0\u{3}first_seen_ns\0\u{3}last_seen_ns\0\u{1}x\0\u{1}y\0\u{1}z\0\u{1}vx\0\u{1}vy\0\u{1}vz\0\u{3}speed_mps\0\u{3}heading_rad\0\u{3}covariance_4x4\0\u{3}bbox_length_avg\0\u{3}bbox_width_avg\0\u{3}bbox_height_avg\0\u{3}bbox_heading_rad\0\u{3}height_p95_max\0\u{3}intensity_mean_avg\0\u{3}avg_speed_mps\0\u{3}peak_speed_mps\0\u{3}class_label\0\u{3}class_confidence\0\u{3}track_length_metres\0\u{3}track_duration_secs\0\u{3}occlusion_count\0\u{1}confidence\0\u{3}occlusion_state\0\u{3}motion_model\0")

  fileprivate class _StorageClass {
    var _trackID: String = String()
    var _sensorID: String = String()
    var _state: Velocity_Visualiser_V1_TrackState = .unknown
    var _hits: Int32 = 0
    var _misses: Int32 = 0
    var _observationCount: Int32 = 0
    var _firstSeenNs: Int64 = 0
    var _lastSeenNs: Int64 = 0
    var _x: Float = 0
    var _y: Float = 0
    var _z: Float = 0
    var _vx: Float = 0
    var _vy: Float = 0
    var _vz: Float = 0
    var _speedMps: Float = 0
    var _headingRad: Float = 0
    var _covariance4X4: [Float] = []
    var _bboxLengthAvg: Float = 0
    var _bboxWidthAvg: Float = 0
    var _bboxHeightAvg: Float = 0
    var _bboxHeadingRad: Float = 0
    var _heightP95Max: Float = 0
    var _intensityMeanAvg: Float = 0
    var _avgSpeedMps: Float = 0
    var _peakSpeedMps: Float = 0
    var _classLabel: String = String()
    var _classConfidence: Float = 0
    var _trackLengthMetres: Float = 0
    var _trackDurationSecs: Float = 0
    var _occlusionCount: Int32 = 0
    var _confidence: Float = 0
    var _occlusionState: Velocity_Visualiser_V1_OcclusionState = .occlusionNone
    var _motionModel: Velocity_Visualiser_V1_MotionModel = .cv

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _trackID = source._trackID
      _sensorID = source._sensorID
      _state = source._state
      _hits = source._hits
      _misses = source._misses
      _observationCount = source._observationCount
      _firstSeenNs = source._firstSeenNs
      _lastSeenNs = source._lastSeenNs
      _x = source._x
      _y = source._y
      _z = source._z
      _vx = source._vx
      _vy = source._vy
      _vz = source._vz
      _speedMps = source._speedMps
      _headingRad = source._headingRad
      _covariance4X4 = source._covariance4X4
      _bboxLengthAvg = source._bboxLengthAvg
      _bboxWidthAvg = source._bboxWidthAvg
      _bboxHeightAvg = source._bboxHeightAvg
      _bboxHeadingRad = source._bboxHeadingRad
      _heightP95Max = source._heightP95Max
      _intensityMeanAvg = source._intensityMeanAvg
      _avgSpeedMps = source._avgSpeedMps
      _peakSpeedMps = source._peakSpeedMps
      _classLabel = source._classLabel
      _classConfidence = source._classConfidence
      _trackLengthMetres = source._trackLengthMetres
      _trackDurationSecs = source._trackDurationSecs
      _occlusionCount = source._occlusionCount
      _confidence = source._confidence
      _occlusionState = source._occlusionState
      _motionModel = source._motionModel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._trackID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sensorID) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._hits) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._misses) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._observationCount) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._firstSeenNs) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._lastSeenNs) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._x) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._y) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._z) }()
        case 12: try { try decoder.decodeSingularFloatField(value: &_storage._vx) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._vy) }()
        case 14: try { try decoder.decodeSingularFloatField(value: &_storage._vz) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._speedMps) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._headingRad) }()
        case 17: try { try decoder.decodeRepeatedFloatField(value: &_storage._covariance4X4) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._bboxLengthAvg) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._bboxWidthAvg) }()
        case 20: try { try decoder.decodeSingularFloatField(value: &_storage._bboxHeightAvg) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._bboxHeadingRad) }()
        case 22: try { try decoder.decodeSingularFloatField(value: &_storage._heightP95Max) }()
        case 23: try { try decoder.decodeSingularFloatField(value: &_storage._intensityMeanAvg) }()
        case 24: try { try decoder.decodeSingularFloatField(value: &_storage._avgSpeedMps) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._peakSpeedMps) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._classLabel) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._classConfidence) }()
        case 28: try { try decoder.decodeSingularFloatField(value: &_storage._trackLengthMetres) }()
        case 29: try { try decoder.decodeSingularFloatField(value: &_storage._trackDurationSecs) }()
        case 30: try { try decoder.decodeSingularInt32Field(value: &_storage._occlusionCount) }()
        case 31: try { try decoder.decodeSingularFloatField(value: &_storage._confidence) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._occlusionState) }()
        case 33: try { try decoder.decodeSingularEnumField(value: &_storage._motionModel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._trackID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trackID, fieldNumber: 1)
      }
      if !_storage._sensorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorID, fieldNumber: 2)
      }
      if _storage._state != .unknown {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      if _storage._hits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._hits, fieldNumber: 4)
      }
      if _storage._misses != 0 {
        try visitor.visitSingularInt32Field(value: _storage._misses, fieldNumber: 5)
      }
      if _storage._observationCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._observationCount, fieldNumber: 6)
      }
      if _storage._firstSeenNs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._firstSeenNs, fieldNumber: 7)
      }
      if _storage._lastSeenNs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastSeenNs, fieldNumber: 8)
      }
      if _storage._x.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._x, fieldNumber: 9)
      }
      if _storage._y.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._y, fieldNumber: 10)
      }
      if _storage._z.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._z, fieldNumber: 11)
      }
      if _storage._vx.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._vx, fieldNumber: 12)
      }
      if _storage._vy.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._vy, fieldNumber: 13)
      }
      if _storage._vz.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._vz, fieldNumber: 14)
      }
      if _storage._speedMps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._speedMps, fieldNumber: 15)
      }
      if _storage._headingRad.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._headingRad, fieldNumber: 16)
      }
      if !_storage._covariance4X4.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._covariance4X4, fieldNumber: 17)
      }
      if _storage._bboxLengthAvg.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._bboxLengthAvg, fieldNumber: 18)
      }
      if _storage._bboxWidthAvg.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._bboxWidthAvg, fieldNumber: 19)
      }
      if _storage._bboxHeightAvg.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._bboxHeightAvg, fieldNumber: 20)
      }
      if _storage._bboxHeadingRad.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._bboxHeadingRad, fieldNumber: 21)
      }
      if _storage._heightP95Max.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._heightP95Max, fieldNumber: 22)
      }
      if _storage._intensityMeanAvg.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._intensityMeanAvg, fieldNumber: 23)
      }
      if _storage._avgSpeedMps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._avgSpeedMps, fieldNumber: 24)
      }
      if _storage._peakSpeedMps.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._peakSpeedMps, fieldNumber: 25)
      }
      if !_storage._classLabel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._classLabel, fieldNumber: 26)
      }
      if _storage._classConfidence.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._classConfidence, fieldNumber: 27)
      }
      if _storage._trackLengthMetres.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._trackLengthMetres, fieldNumber: 28)
      }
      if _storage._trackDurationSecs.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._trackDurationSecs, fieldNumber: 29)
      }
      if _storage._occlusionCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._occlusionCount, fieldNumber: 30)
      }
      if _storage._confidence.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._confidence, fieldNumber: 31)
      }
      if _storage._occlusionState != .occlusionNone {
        try visitor.visitSingularEnumField(value: _storage._occlusionState, fieldNumber: 32)
      }
      if _storage._motionModel != .cv {
        try visitor.visitSingularEnumField(value: _storage._motionModel, fieldNumber: 33)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_Track, rhs: Velocity_Visualiser_V1_Track) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trackID != rhs_storage._trackID {return false}
        if _storage._sensorID != rhs_storage._sensorID {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._hits != rhs_storage._hits {return false}
        if _storage._misses != rhs_storage._misses {return false}
        if _storage._observationCount != rhs_storage._observationCount {return false}
        if _storage._firstSeenNs != rhs_storage._firstSeenNs {return false}
        if _storage._lastSeenNs != rhs_storage._lastSeenNs {return false}
        if _storage._x != rhs_storage._x {return false}
        if _storage._y != rhs_storage._y {return false}
        if _storage._z != rhs_storage._z {return false}
        if _storage._vx != rhs_storage._vx {return false}
        if _storage._vy != rhs_storage._vy {return false}
        if _storage._vz != rhs_storage._vz {return false}
        if _storage._speedMps != rhs_storage._speedMps {return false}
        if _storage._headingRad != rhs_storage._headingRad {return false}
        if _storage._covariance4X4 != rhs_storage._covariance4X4 {return false}
        if _storage._bboxLengthAvg != rhs_storage._bboxLengthAvg {return false}
        if _storage._bboxWidthAvg != rhs_storage._bboxWidthAvg {return false}
        if _storage._bboxHeightAvg != rhs_storage._bboxHeightAvg {return false}
        if _storage._bboxHeadingRad != rhs_storage._bboxHeadingRad {return false}
        if _storage._heightP95Max != rhs_storage._heightP95Max {return false}
        if _storage._intensityMeanAvg != rhs_storage._intensityMeanAvg {return false}
        if _storage._avgSpeedMps != rhs_storage._avgSpeedMps {return false}
        if _storage._peakSpeedMps != rhs_storage._peakSpeedMps {return false}
        if _storage._classLabel != rhs_storage._classLabel {return false}
        if _storage._classConfidence != rhs_storage._classConfidence {return false}
        if _storage._trackLengthMetres != rhs_storage._trackLengthMetres {return false}
        if _storage._trackDurationSecs != rhs_storage._trackDurationSecs {return false}
        if _storage._occlusionCount != rhs_storage._occlusionCount {return false}
        if _storage._confidence != rhs_storage._confidence {return false}
        if _storage._occlusionState != rhs_storage._occlusionState {return false}
        if _storage._motionModel != rhs_storage._motionModel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_TrackPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackPoint"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{3}timestamp_ns\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampNs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampNs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_TrackPoint, rhs: Velocity_Visualiser_V1_TrackPoint) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_TrackTrail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackTrail"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}track_id\0\u{1}points\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_TrackTrail, rhs: Velocity_Visualiser_V1_TrackTrail) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_TrackSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackSet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frame_id\0\u{3}timestamp_ns\0\u{1}tracks\0\u{1}trails\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.frameID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampNs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.trails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.frameID, fieldNumber: 1)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampNs, fieldNumber: 2)
    }
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 3)
    }
    if !self.trails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trails, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_TrackSet, rhs: Velocity_Visualiser_V1_TrackSet) -> Bool {
    if lhs.frameID != rhs.frameID {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.tracks != rhs.tracks {return false}
    if lhs.trails != rhs.trails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_AssociationCandidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssociationCandidate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cluster_id\0\u{3}track_id\0\u{1}distance\0\u{1}accepted\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clusterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.distance) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.accepted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clusterID != 0 {
      try visitor.visitSingularInt64Field(value: self.clusterID, fieldNumber: 1)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 2)
    }
    if self.distance.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.distance, fieldNumber: 3)
    }
    if self.accepted != false {
      try visitor.visitSingularBoolField(value: self.accepted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_AssociationCandidate, rhs: Velocity_Visualiser_V1_AssociationCandidate) -> Bool {
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.accepted != rhs.accepted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_GatingEllipse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GatingEllipse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}track_id\0\u{3}center_x\0\u{3}center_y\0\u{3}semi_major\0\u{3}semi_minor\0\u{3}rotation_rad\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.centerX) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.centerY) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.semiMajor) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.semiMinor) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.rotationRad) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if self.centerX.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.centerX, fieldNumber: 2)
    }
    if self.centerY.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.centerY, fieldNumber: 3)
    }
    if self.semiMajor.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.semiMajor, fieldNumber: 4)
    }
    if self.semiMinor.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.semiMinor, fieldNumber: 5)
    }
    if self.rotationRad.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rotationRad, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_GatingEllipse, rhs: Velocity_Visualiser_V1_GatingEllipse) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.centerX != rhs.centerX {return false}
    if lhs.centerY != rhs.centerY {return false}
    if lhs.semiMajor != rhs.semiMajor {return false}
    if lhs.semiMinor != rhs.semiMinor {return false}
    if lhs.rotationRad != rhs.rotationRad {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_InnovationResidual: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InnovationResidual"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}track_id\0\u{3}predicted_x\0\u{3}predicted_y\0\u{3}measured_x\0\u{3}measured_y\0\u{3}residual_magnitude\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.predictedX) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.predictedY) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.measuredX) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.measuredY) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.residualMagnitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if self.predictedX.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.predictedX, fieldNumber: 2)
    }
    if self.predictedY.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.predictedY, fieldNumber: 3)
    }
    if self.measuredX.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.measuredX, fieldNumber: 4)
    }
    if self.measuredY.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.measuredY, fieldNumber: 5)
    }
    if self.residualMagnitude.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.residualMagnitude, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_InnovationResidual, rhs: Velocity_Visualiser_V1_InnovationResidual) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.predictedX != rhs.predictedX {return false}
    if lhs.predictedY != rhs.predictedY {return false}
    if lhs.measuredX != rhs.measuredX {return false}
    if lhs.measuredY != rhs.measuredY {return false}
    if lhs.residualMagnitude != rhs.residualMagnitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_StatePrediction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatePrediction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}track_id\0\u{1}x\0\u{1}y\0\u{1}vx\0\u{1}vy\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.vx) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.vy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 1)
    }
    if self.x.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 2)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 3)
    }
    if self.vx.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.vx, fieldNumber: 4)
    }
    if self.vy.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.vy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_StatePrediction, rhs: Velocity_Visualiser_V1_StatePrediction) -> Bool {
    if lhs.trackID != rhs.trackID {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.vx != rhs.vx {return false}
    if lhs.vy != rhs.vy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_DebugOverlaySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugOverlaySet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frame_id\0\u{3}timestamp_ns\0\u{3}association_candidates\0\u{3}gating_ellipses\0\u{1}residuals\0\u{1}predictions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.frameID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampNs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.associationCandidates) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.gatingEllipses) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.residuals) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.predictions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.frameID, fieldNumber: 1)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampNs, fieldNumber: 2)
    }
    if !self.associationCandidates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.associationCandidates, fieldNumber: 3)
    }
    if !self.gatingEllipses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gatingEllipses, fieldNumber: 4)
    }
    if !self.residuals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.residuals, fieldNumber: 5)
    }
    if !self.predictions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.predictions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_DebugOverlaySet, rhs: Velocity_Visualiser_V1_DebugOverlaySet) -> Bool {
    if lhs.frameID != rhs.frameID {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.associationCandidates != rhs.associationCandidates {return false}
    if lhs.gatingEllipses != rhs.gatingEllipses {return false}
    if lhs.residuals != rhs.residuals {return false}
    if lhs.predictions != rhs.predictions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_LabelEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}label_id\0\u{3}track_id\0\u{3}class_label\0\u{3}start_frame_id\0\u{3}end_frame_id\0\u{3}created_ns\0\u{1}annotator\0\u{1}notes\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.labelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.trackID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.classLabel) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.startFrameID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.endFrameID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.createdNs) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.annotator) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labelID.isEmpty {
      try visitor.visitSingularStringField(value: self.labelID, fieldNumber: 1)
    }
    if !self.trackID.isEmpty {
      try visitor.visitSingularStringField(value: self.trackID, fieldNumber: 2)
    }
    if !self.classLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.classLabel, fieldNumber: 3)
    }
    if self.startFrameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.startFrameID, fieldNumber: 4)
    }
    if self.endFrameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.endFrameID, fieldNumber: 5)
    }
    if self.createdNs != 0 {
      try visitor.visitSingularInt64Field(value: self.createdNs, fieldNumber: 6)
    }
    if !self.annotator.isEmpty {
      try visitor.visitSingularStringField(value: self.annotator, fieldNumber: 7)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_LabelEvent, rhs: Velocity_Visualiser_V1_LabelEvent) -> Bool {
    if lhs.labelID != rhs.labelID {return false}
    if lhs.trackID != rhs.trackID {return false}
    if lhs.classLabel != rhs.classLabel {return false}
    if lhs.startFrameID != rhs.startFrameID {return false}
    if lhs.endFrameID != rhs.endFrameID {return false}
    if lhs.createdNs != rhs.createdNs {return false}
    if lhs.annotator != rhs.annotator {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_LabelSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelSet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0\u{3}source_file\0\u{1}labels\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceFile) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.sourceFile.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceFile, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_LabelSet, rhs: Velocity_Visualiser_V1_LabelSet) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.sourceFile != rhs.sourceFile {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_PlaybackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaybackInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_live\0\u{3}log_start_ns\0\u{3}log_end_ns\0\u{3}playback_rate\0\u{1}paused\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLive) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.logStartNs) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.logEndNs) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.playbackRate) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.paused) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isLive != false {
      try visitor.visitSingularBoolField(value: self.isLive, fieldNumber: 1)
    }
    if self.logStartNs != 0 {
      try visitor.visitSingularInt64Field(value: self.logStartNs, fieldNumber: 2)
    }
    if self.logEndNs != 0 {
      try visitor.visitSingularInt64Field(value: self.logEndNs, fieldNumber: 3)
    }
    if self.playbackRate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.playbackRate, fieldNumber: 4)
    }
    if self.paused != false {
      try visitor.visitSingularBoolField(value: self.paused, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_PlaybackInfo, rhs: Velocity_Visualiser_V1_PlaybackInfo) -> Bool {
    if lhs.isLive != rhs.isLive {return false}
    if lhs.logStartNs != rhs.logStartNs {return false}
    if lhs.logEndNs != rhs.logEndNs {return false}
    if lhs.playbackRate != rhs.playbackRate {return false}
    if lhs.paused != rhs.paused {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_FrameBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FrameBundle"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frame_id\0\u{3}timestamp_ns\0\u{3}sensor_id\0\u{3}coordinate_frame\0\u{3}point_cloud\0\u{1}clusters\0\u{1}tracks\0\u{1}debug\0\u{3}playback_info\0")

  fileprivate class _StorageClass {
    var _frameID: UInt64 = 0
    var _timestampNs: Int64 = 0
    var _sensorID: String = String()
    var _coordinateFrame: Velocity_Visualiser_V1_CoordinateFrameInfo? = nil
    var _pointCloud: Velocity_Visualiser_V1_PointCloudFrame? = nil
    var _clusters: Velocity_Visualiser_V1_ClusterSet? = nil
    var _tracks: Velocity_Visualiser_V1_TrackSet? = nil
    var _debug: Velocity_Visualiser_V1_DebugOverlaySet? = nil
    var _playbackInfo: Velocity_Visualiser_V1_PlaybackInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _frameID = source._frameID
      _timestampNs = source._timestampNs
      _sensorID = source._sensorID
      _coordinateFrame = source._coordinateFrame
      _pointCloud = source._pointCloud
      _clusters = source._clusters
      _tracks = source._tracks
      _debug = source._debug
      _playbackInfo = source._playbackInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._frameID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._timestampNs) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._sensorID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._coordinateFrame) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pointCloud) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._clusters) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tracks) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._debug) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._playbackInfo) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._frameID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._frameID, fieldNumber: 1)
      }
      if _storage._timestampNs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampNs, fieldNumber: 2)
      }
      if !_storage._sensorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorID, fieldNumber: 3)
      }
      try { if let v = _storage._coordinateFrame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._pointCloud {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._clusters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tracks {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._debug {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._playbackInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_FrameBundle, rhs: Velocity_Visualiser_V1_FrameBundle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._frameID != rhs_storage._frameID {return false}
        if _storage._timestampNs != rhs_storage._timestampNs {return false}
        if _storage._sensorID != rhs_storage._sensorID {return false}
        if _storage._coordinateFrame != rhs_storage._coordinateFrame {return false}
        if _storage._pointCloud != rhs_storage._pointCloud {return false}
        if _storage._clusters != rhs_storage._clusters {return false}
        if _storage._tracks != rhs_storage._tracks {return false}
        if _storage._debug != rhs_storage._debug {return false}
        if _storage._playbackInfo != rhs_storage._playbackInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_StreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sensor_id\0\u{3}include_points\0\u{3}include_clusters\0\u{3}include_tracks\0\u{3}include_debug\0\u{3}point_decimation\0\u{3}decimation_ratio\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sensorID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includePoints) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeClusters) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeTracks) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeDebug) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.pointDecimation) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.decimationRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensorID.isEmpty {
      try visitor.visitSingularStringField(value: self.sensorID, fieldNumber: 1)
    }
    if self.includePoints != false {
      try visitor.visitSingularBoolField(value: self.includePoints, fieldNumber: 2)
    }
    if self.includeClusters != false {
      try visitor.visitSingularBoolField(value: self.includeClusters, fieldNumber: 3)
    }
    if self.includeTracks != false {
      try visitor.visitSingularBoolField(value: self.includeTracks, fieldNumber: 4)
    }
    if self.includeDebug != false {
      try visitor.visitSingularBoolField(value: self.includeDebug, fieldNumber: 5)
    }
    if self.pointDecimation != .decimationNone {
      try visitor.visitSingularEnumField(value: self.pointDecimation, fieldNumber: 6)
    }
    if self.decimationRatio.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.decimationRatio, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_StreamRequest, rhs: Velocity_Visualiser_V1_StreamRequest) -> Bool {
    if lhs.sensorID != rhs.sensorID {return false}
    if lhs.includePoints != rhs.includePoints {return false}
    if lhs.includeClusters != rhs.includeClusters {return false}
    if lhs.includeTracks != rhs.includeTracks {return false}
    if lhs.includeDebug != rhs.includeDebug {return false}
    if lhs.pointDecimation != rhs.pointDecimation {return false}
    if lhs.decimationRatio != rhs.decimationRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_PlaybackStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaybackStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}paused\0\u{1}rate\0\u{3}current_timestamp_ns\0\u{3}current_frame_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.paused) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.rate) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.currentTimestampNs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.currentFrameID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paused != false {
      try visitor.visitSingularBoolField(value: self.paused, fieldNumber: 1)
    }
    if self.rate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rate, fieldNumber: 2)
    }
    if self.currentTimestampNs != 0 {
      try visitor.visitSingularInt64Field(value: self.currentTimestampNs, fieldNumber: 3)
    }
    if self.currentFrameID != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentFrameID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_PlaybackStatus, rhs: Velocity_Visualiser_V1_PlaybackStatus) -> Bool {
    if lhs.paused != rhs.paused {return false}
    if lhs.rate != rhs.rate {return false}
    if lhs.currentTimestampNs != rhs.currentTimestampNs {return false}
    if lhs.currentFrameID != rhs.currentFrameID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_PauseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PauseRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_PauseRequest, rhs: Velocity_Visualiser_V1_PauseRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_PlayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_PlayRequest, rhs: Velocity_Visualiser_V1_PlayRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_SeekRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SeekRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timestamp_ns\0\u{3}frame_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .timestampNs(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .frameID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .timestampNs?: try {
      guard case .timestampNs(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .frameID?: try {
      guard case .frameID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_SeekRequest, rhs: Velocity_Visualiser_V1_SeekRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_SetRateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetRateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rate\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_SetRateRequest, rhs: Velocity_Visualiser_V1_SetRateRequest) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_OverlayModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OverlayModeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}show_points\0\u{3}show_clusters\0\u{3}show_tracks\0\u{3}show_trails\0\u{3}show_velocity\0\u{3}show_gating\0\u{3}show_association\0\u{3}show_residuals\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.showPoints) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showClusters) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.showTracks) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showTrails) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.showVelocity) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.showGating) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.showAssociation) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.showResiduals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.showPoints != false {
      try visitor.visitSingularBoolField(value: self.showPoints, fieldNumber: 1)
    }
    if self.showClusters != false {
      try visitor.visitSingularBoolField(value: self.showClusters, fieldNumber: 2)
    }
    if self.showTracks != false {
      try visitor.visitSingularBoolField(value: self.showTracks, fieldNumber: 3)
    }
    if self.showTrails != false {
      try visitor.visitSingularBoolField(value: self.showTrails, fieldNumber: 4)
    }
    if self.showVelocity != false {
      try visitor.visitSingularBoolField(value: self.showVelocity, fieldNumber: 5)
    }
    if self.showGating != false {
      try visitor.visitSingularBoolField(value: self.showGating, fieldNumber: 6)
    }
    if self.showAssociation != false {
      try visitor.visitSingularBoolField(value: self.showAssociation, fieldNumber: 7)
    }
    if self.showResiduals != false {
      try visitor.visitSingularBoolField(value: self.showResiduals, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_OverlayModeRequest, rhs: Velocity_Visualiser_V1_OverlayModeRequest) -> Bool {
    if lhs.showPoints != rhs.showPoints {return false}
    if lhs.showClusters != rhs.showClusters {return false}
    if lhs.showTracks != rhs.showTracks {return false}
    if lhs.showTrails != rhs.showTrails {return false}
    if lhs.showVelocity != rhs.showVelocity {return false}
    if lhs.showGating != rhs.showGating {return false}
    if lhs.showAssociation != rhs.showAssociation {return false}
    if lhs.showResiduals != rhs.showResiduals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_OverlayModeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OverlayModeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_OverlayModeResponse, rhs: Velocity_Visualiser_V1_OverlayModeResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_CapabilitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CapabilitiesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_CapabilitiesRequest, rhs: Velocity_Visualiser_V1_CapabilitiesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_CapabilitiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CapabilitiesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}supports_points\0\u{3}supports_clusters\0\u{3}supports_tracks\0\u{3}supports_debug\0\u{3}supports_replay\0\u{3}supports_recording\0\u{3}available_sensors\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.supportsPoints) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.supportsClusters) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.supportsTracks) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.supportsDebug) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.supportsReplay) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.supportsRecording) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.availableSensors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.supportsPoints != false {
      try visitor.visitSingularBoolField(value: self.supportsPoints, fieldNumber: 1)
    }
    if self.supportsClusters != false {
      try visitor.visitSingularBoolField(value: self.supportsClusters, fieldNumber: 2)
    }
    if self.supportsTracks != false {
      try visitor.visitSingularBoolField(value: self.supportsTracks, fieldNumber: 3)
    }
    if self.supportsDebug != false {
      try visitor.visitSingularBoolField(value: self.supportsDebug, fieldNumber: 4)
    }
    if self.supportsReplay != false {
      try visitor.visitSingularBoolField(value: self.supportsReplay, fieldNumber: 5)
    }
    if self.supportsRecording != false {
      try visitor.visitSingularBoolField(value: self.supportsRecording, fieldNumber: 6)
    }
    if !self.availableSensors.isEmpty {
      try visitor.visitRepeatedStringField(value: self.availableSensors, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_CapabilitiesResponse, rhs: Velocity_Visualiser_V1_CapabilitiesResponse) -> Bool {
    if lhs.supportsPoints != rhs.supportsPoints {return false}
    if lhs.supportsClusters != rhs.supportsClusters {return false}
    if lhs.supportsTracks != rhs.supportsTracks {return false}
    if lhs.supportsDebug != rhs.supportsDebug {return false}
    if lhs.supportsReplay != rhs.supportsReplay {return false}
    if lhs.supportsRecording != rhs.supportsRecording {return false}
    if lhs.availableSensors != rhs.availableSensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_RecordingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}output_path\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputPath.isEmpty {
      try visitor.visitSingularStringField(value: self.outputPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_RecordingRequest, rhs: Velocity_Visualiser_V1_RecordingRequest) -> Bool {
    if lhs.outputPath != rhs.outputPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Velocity_Visualiser_V1_RecordingStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordingStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}recording\0\u{3}output_path\0\u{3}frames_recorded\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.recording) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.outputPath) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.framesRecorded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.recording != false {
      try visitor.visitSingularBoolField(value: self.recording, fieldNumber: 1)
    }
    if !self.outputPath.isEmpty {
      try visitor.visitSingularStringField(value: self.outputPath, fieldNumber: 2)
    }
    if self.framesRecorded != 0 {
      try visitor.visitSingularUInt64Field(value: self.framesRecorded, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Velocity_Visualiser_V1_RecordingStatus, rhs: Velocity_Visualiser_V1_RecordingStatus) -> Bool {
    if lhs.recording != rhs.recording {return false}
    if lhs.outputPath != rhs.outputPath {return false}
    if lhs.framesRecorded != rhs.framesRecorded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
